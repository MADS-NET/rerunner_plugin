/*
  ____  _       _#include <datastore.hpp>
#include <chrono>
#include <deque>
#include <memory>
#include <optional>
#include <rerun/rerun.hpp>
#include <unordered_map>

// other includes as needed here    _             _
 / ___|(_)_ __ | | __  _ __ | |_   _  __ _(_)_ __
 \___ \| | '_ \| |/ / | '_ \| | | | |/ _` | | '_ \
  ___) | | | | |   <  | |_) | | |_| | (_| | | | | |
 |____/|_|_| |_|_|\_\ | .__/|_|\__,_|\__, |_|_| |_|
                      |_|            |___/
# A Template for RerunPlugin, a Sink Plugin
# Generated by the command: plugin -t sink -d rerun_plugin -s rerun
# Hostname: Fram-IV.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2025-09-08T16:35:50.334+0200
# NOTICE: MADS Version 1.3.5
*/

// Mandatory included headers
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
#include <sink.hpp>

#include "moving_window_stats.hpp"
#include <BS_thread_pool.hpp>
#include <array>
#include <chrono>
#include <datastore.hpp>
#include <deque>
#include <filesystem>
#include <future>
#include <memory>
#include <optional>
#include <rerun.hpp>
#include <unordered_map>
#include <vector>

// other includes as needed here

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "rerun"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
#include <deque>
#include <unordered_map>

class RerunnerPlugin : public Sink<json> {
private:
  std::vector<std::string> _keypaths;
  std::vector<std::string> _acf_keypaths;
  std::vector<std::string> _fft_keypaths;
  std::vector<std::string> _trace_keypaths;
  MovingWindowStats _stats;
  size_t _window_size = 1000; // Store 10x ACF width for better statistics
  filesystem::path _blueprint;

  std::chrono::steady_clock::time_point _start_time;
  std::shared_ptr<rerun::RecordingStream> _rec;

  BS::thread_pool<BS::tp::none> _pool;
  vector<future<bool>> _futures;

  // Helper function to convert dot notation path to JSON value
  json::json_pointer dot_to_pointer(const std::string &dot_path) {
    std::string result;
    std::string token;
    bool in_brackets = false;
    if (dot_path[0] == '/') 
      return json::json_pointer(dot_path);

    for (char c : dot_path) {
      if (c == '[') {
        if (!token.empty()) {
          result += "/" + token;
          token.clear();
        }
        in_brackets = true;
      } else if (c == ']') {
        if (!token.empty()) {
          result += "/" + token;
          token.clear();
        }
        in_brackets = false;
      } else if (c == '.' && !in_brackets) {
        if (!token.empty()) {
          result += "/" + token;
          token.clear();
        }
      } else {
        token += c;
      }
    }

    if (!token.empty()) {
      result += "/" + token;
    }

    return json::json_pointer(result);
  }

  // Helper function to safely get a value from JSON using dot notation
  std::optional<double> get_numeric_value(const json &j,
                                          const std::string &dot_path) {
    json::json_pointer ptr = dot_to_pointer(dot_path);

    try {
      const auto &value = j[ptr];

      if (value.is_number()) {
        return value.get<double>();
      }
    } catch (const json::exception &e) {
      // Path doesn't exist or other JSON error
    }
    return std::nullopt;
  }

public:
  RerunnerPlugin() {
    _start_time = std::chrono::steady_clock::now();
  }

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    static double prev_time = 0;
    static double mean_dt = 0;
    static size_t n = 0;
    double dt = 0;
    bool logged = false;
    if (topic.empty()) {
      _error = "No topic specified in plugin load_data()";
      return return_type::error;
    }

    auto now = std::chrono::steady_clock::now();
    double time_seconds;
    // get the timecode from the input json if available, otherwise use elapsed
    // time
    if (!_params["time"].empty() && input.contains(_params["time"])) {
      time_seconds = input[_params["time"]].get<double>();
    } else {
      time_seconds = std::chrono::duration<double>(now - _start_time).count();
    }

    dt = time_seconds - prev_time;

    // embed the input json within a parent object named as the topic
    json data = json{{topic, std::move(input)}};


    // Extract values for each keypath and send to rerun
    if (_params["parallelize"].get<bool>()) {
      for (const auto &keypath : _keypaths) {
        if (auto value = get_numeric_value(data, keypath)) {
          _rec->log("data/" + keypath, rerun::Scalars(*value));
          _futures.push_back(_pool.submit_task(
              [&] { return _stats.add(keypath, value.value_or(0)); }));
        }
      }
      for (const auto &f : _futures) {
        f.wait();
      }
      for (const auto &keypath : _keypaths) {
        _rec->log("stats/mean/" + keypath,
                  rerun::Scalars(_stats.mean(keypath)));
        _rec->log("stats/stdev/" + keypath,
                  rerun::Scalars(_stats.stdev(keypath)));
        _rec->log("stats/std_uncertainty/" + keypath,
                  rerun::Scalars(_stats.st_uncertainty(keypath)));
        logged = true;
      }
    } else {
      for (const auto &keypath : _keypaths) {
        if (auto value = get_numeric_value(data, keypath)) {
          _stats.add(keypath, value.value_or(0));
          _rec->log("data/" + keypath, rerun::Scalars(*value));
          _rec->log("stats/mean/" + keypath,
                    rerun::Scalars(_stats.mean(keypath)));
          _rec->log("stats/stdev/" + keypath,
                    rerun::Scalars(_stats.stdev(keypath)));
          _rec->log("stats/std_uncertainty/" + keypath,
                    rerun::Scalars(_stats.st_uncertainty(keypath)));
          logged = true;
        }
      }
    }

    // Traces
    for (const auto &keypath : _trace_keypaths) {
      json::json_pointer ptr(dot_to_pointer(keypath));
      if (data[ptr].is_array() && data[ptr].size() == 3) {
        _rec->log("trace/" + keypath, rerun::Points3D(rerun::Position3D(data[ptr])));
        logged = true;
      }
    }

    // Process ACF keypaths
    for (const auto &keypath : _acf_keypaths) {
      if (_stats.is_full(keypath)) {
        _rec->log("acf_plot/" + keypath,
                  rerun::BarChart::f64(_stats.acf(keypath)));
        logged = true;
      }
    }

    // Process FFT keypaths
    if (!_fft_keypaths.empty()) {
      size_t len = _window_size / 2.0;
#ifdef WITH_ABSCISSA
      vector<double> abscissa;
      abscissa.reserve(len);
      for (size_t i = 1; i <= len; i++) {
        abscissa.push_back(i * 1 / mean_dt / 2.0 / (double)_window_size);
      }
      auto abscissa_data = rerun::TensorData(rerun::Collection{len}, abscissa);
#endif
      for (const auto &keypath : _fft_keypaths) {
        if (_stats.is_full(keypath)) {
          _rec->log("fft_plot/" + keypath,
#ifdef WITH_ABSCISSA
                    rerun::BarChart::f64(_stats.fft(keypath))
                        .with_abscissa(abscissa_data));
#else
                    rerun::BarChart::f64(_stats.fft(keypath)));
#endif
          logged = true;
        }
      }
    }

    if (logged) {
      if (n > 0) {
        mean_dt = ((n - 1) * mean_dt + dt) / (double)n;
        _rec->log("stats/timestep", rerun::Scalars(dt));
        _rec->log("stats/mean_timestep", rerun::Scalars(mean_dt));
      }
      prev_time = time_seconds;
      n++;
      // Set the current time for this batch of data
      _rec->set_time_duration_secs("time", time_seconds);
      return return_type::retry;
    } else 
      return return_type::success;
  }

  void set_params(void const *params) override {
    // Call the parent class method to set the common parameters
    // (e.g. agent_id, etc.)
    Sink::set_params(params);

    // provide sensible defaults for the parameters
    _params["keypaths"] = json::array();       // empty array by default
    _params["acf_keypaths"] = json::array();   // empty array by default
    _params["fft_keypaths"] = json::array();   // empty array by default
    _params["trace_keypaths"] = json::array(); // empty array by default
    _params["window_size"] = 100;              // default ACF width
    _params["time"] = "timecode";
    _params["blueprint"] = "";
    _params["parallelize"] = true;

    // then merge the defaults with the actually provided parameters
    _params.merge_patch(*(json *)params);
    _window_size = _params.value("window_size", 200);
    _stats.reset(_window_size);

    _rec = std::make_shared<rerun::RecordingStream>("MADS " + _params.value("agent_name", "rerunner (generic)"));
    _rec->spawn().exit_on_failure();

    if (!_agent_id.empty()) {
      _rec->send_recording_name(_agent_id);
    }

    _blueprint = _params.value("blueprint", "");
    if (filesystem::exists(_blueprint)) {
      _rec->log_file_from_path(_blueprint);
    } else if (!_blueprint.empty()) {
      _blueprint = _params.value("blueprint", "") + " (not found)";
    }

    // Load the keypaths configuration
    _keypaths.clear();
    if (_params.contains("keypaths") && _params["keypaths"].is_array()) {
      for (const auto &path : _params["keypaths"]) {
        if (path.is_string()) {
          _keypaths.push_back(path.get<std::string>());
        }
      }
    }

    // Load ACF configuration
    _acf_keypaths.clear();
    if (_params.contains("acf_keypaths") &&
        _params["acf_keypaths"].is_array()) {
      for (const auto &path : _params["acf_keypaths"]) {
        if (path.is_string()) {
          _acf_keypaths.push_back(path.get<std::string>());
          // Initialize buffer for this keypath
          // _signal_buffers[path.get<std::string>()];
        }
      }
    }

    // Load FFT configuration
    _fft_keypaths.clear();
    if (_params.contains("fft_keypaths") &&
        _params["fft_keypaths"].is_array()) {
      for (const auto &path : _params["fft_keypaths"]) {
        if (path.is_string()) {
          _fft_keypaths.push_back(path.get<std::string>());
          // Initialize buffer for this keypath
          // _signal_buffers[path.get<std::string>()];
        }
      }
    }

    // Load trace configuration
    _trace_keypaths.clear();
    if (_params.contains("trace_keypaths") &&
        _params["trace_keypaths"].is_array()) {
      for (const auto &path : _params["trace_keypaths"]) {
        if (path.is_string()) {
          _trace_keypaths.push_back(path.get<std::string>());
          // Initialize buffer for this keypath
          // _signal_buffers[path.get<std::string>()];
        }
      }
    }
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override {
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent

    return {{"Rerun version", rerun::version_string()},
            {"Window size", std::to_string(_window_size)},
            {"ACF Keypaths",
             _acf_keypaths.empty() ? "None" : json(_acf_keypaths).dump()},
            {"FFT Keypaths",
             _fft_keypaths.empty() ? "None" : json(_fft_keypaths).dump()},
            {"Trace Keypaths",
             _trace_keypaths.empty() ? "None" : json(_trace_keypaths).dump()},
            {"Keypaths", _keypaths.empty() ? "None" : json(_keypaths).dump()},
            {"Time column", _params["time"].get<string>().empty()
                                ? "timecode"
                                : _params["time"].get<std::string>()},
            {"Blueprint", (_blueprint.empty() ? "None" : _blueprint.string())},
            {"Parallelize", _params["parallelize"].get<bool>() ? to_string(_pool.get_thread_count()) + " threads" : "NO"}
          };
  };
};

/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SINK_DRIVER(RerunnerPlugin, json)

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  RerunnerPlugin plugin;
  json input, params;

  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Process data
  plugin.load_data(input);

  return 0;
}
