/*
  ____  _       _#include <datastore.hpp>
#include <rerun/rerun.hpp>
#include <chrono>
#include <deque>
#include <unordered_map>
#include <optional>
#include <memory>

// other includes as needed here    _             _       
 / ___|(_)_ __ | | __  _ __ | |_   _  __ _(_)_ __  
 \___ \| | '_ \| |/ / | '_ \| | | | |/ _` | | '_ \ 
  ___) | | | | |   <  | |_) | | |_| | (_| | | | | |
 |____/|_|_| |_|_|\_\ | .__/|_|\__,_|\__, |_|_| |_|
                      |_|            |___/         
# A Template for RerunPlugin, a Sink Plugin
# Generated by the command: plugin -t sink -d rerun_plugin -s rerun
# Hostname: Fram-IV.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2025-09-08T16:35:50.334+0200
# NOTICE: MADS Version 1.3.5
*/

// Mandatory included headers
#include <sink.hpp>
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>

#include <datastore.hpp>
#include <rerun.hpp>
#include <chrono>
#include <deque>
#include <unordered_map>
#include <optional>
#include <memory>
#include <vector>

// other includes as needed here

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "rerun"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;


// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
#include <deque>
#include <unordered_map>

class RerunnerPlugin : public Sink<json> {
private:
  std::vector<std::string> _keypaths;
  std::vector<std::string> _acf_keypaths;
  size_t _acf_width = 100;  // default width
  size_t _window_size = 1000;  // Store 10x ACF width for better statistics
  
  // Circular buffers for ACF calculation, one per keypath
  std::unordered_map<std::string, std::deque<double>> _signal_buffers;
  
  std::chrono::steady_clock::time_point _start_time;
  std::shared_ptr<rerun::RecordingStream> _rec;

  // Helper function to calculate ACF for a given signal buffer
  std::vector<double> calculate_acf(const std::deque<double>& buffer) {
    std::vector<double> acf(_acf_width, 0.0);
    if (buffer.size() < _acf_width * 2) {
      return acf;  // Return zeros if not enough data
    }

    // Calculate mean
    double mean = 0.0;
    for (const auto& val : buffer) {
      mean += val;
    }
    mean /= buffer.size();

    // Calculate variance for normalization
    double variance = 0.0;
    for (const auto& val : buffer) {
      double diff = val - mean;
      variance += diff * diff;
    }
    variance /= buffer.size();
    
    if (variance < 1e-10) {
      return acf;  // Return zeros if signal is constant
    }

    // Calculate ACF for each lag
    for (size_t lag = 0; lag < _acf_width; ++lag) {
      double sum = 0.0;
      size_t n = 0;
      
      // Use the most recent window_size samples
      for (size_t i = lag; i < buffer.size(); ++i) {
        double x1 = buffer[i] - mean;
        double x2 = buffer[i - lag] - mean;
        sum += x1 * x2;
        ++n;
      }
      
      acf[lag] = sum / (n * variance);  // Normalized ACF
    }

    return acf;
  }

  // Helper function to convert dot notation path to JSON value
  json::json_pointer dot_to_pointer(const std::string& dot_path) {
    std::string result;
    std::string token;
    bool in_brackets = false;
    
    for (char c : dot_path) {
      if (c == '[') {
        if (!token.empty()) {
          result += "/" + token;
          token.clear();
        }
        in_brackets = true;
      }
      else if (c == ']') {
        if (!token.empty()) {
          result += "/" + token;
          token.clear();
        }
        in_brackets = false;
      }
      else if (c == '.' && !in_brackets) {
        if (!token.empty()) {
          result += "/" + token;
          token.clear();
        }
      }
      else {
        token += c;
      }
    }
    
    if (!token.empty()) {
      result += "/" + token;
    }
    
    return json::json_pointer(result);
  }

  // Helper function to safely get a value from JSON using dot notation
  std::optional<double> get_numeric_value(const json& j, const std::string& dot_path) {
    nlohmann::json::json_pointer ptr;
    if (dot_path[0] == '/') {
      ptr = nlohmann::json::json_pointer(dot_path);
    } else {
      ptr = dot_to_pointer(dot_path);
    }
    try {
      const auto& value = j[ptr];
      
      if (value.is_number()) {
        return value.get<double>();
      }
    } catch (const json::exception& e) {
      // Path doesn't exist or other JSON error
    }
    return std::nullopt;
  }

public:
  RerunnerPlugin() {
    _start_time = std::chrono::steady_clock::now();
    _rec = std::make_shared<rerun::RecordingStream>("MADS Data");
    _rec->spawn().exit_on_failure();
  }

  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  // Implement the actual functionality here
  return_type load_data(json const &input, string topic = "") override {
    if (topic.empty()) {
      _error = "No topic specified in plugin load_data()";
      return return_type::error;
    }

    auto now = std::chrono::steady_clock::now();
    double time_seconds;
    // get the timecode from the input json if available, otherwise use elapsed time
    if (!_params["time"].empty() && input.contains(_params["time"])) {
      time_seconds = input[_params["time"]].get<double>();
    } else {
      time_seconds = std::chrono::duration<double>(now - _start_time).count();
    }

    // embed the input json within a parent object named as the topic
    json data = json{{topic, std::move(input)}};

    // Set the current time for this batch of data
    _rec->set_time_duration_secs("time", time_seconds);
    
    // Extract values for each keypath and send to rerun
    for (const auto& keypath : _keypaths) {
      if (auto value = get_numeric_value(data, keypath)) {
        rerun::Scalars scalar(static_cast<float>(*value));
        _rec->log("data/" + keypath, scalar);
      }
    }

    // Process ACF keypaths
    for (const auto& keypath : _acf_keypaths) {
      if (auto value = get_numeric_value(data, keypath)) {
        // Add value to circular buffer
        auto& buffer = _signal_buffers[keypath];
        buffer.push_back(*value);
        if (buffer.size() > _window_size) {
          buffer.pop_front();
        }

        // Calculate and plot ACF if we have enough data
        if (buffer.size() >= _acf_width * 2) {
          std::vector<double> acf = calculate_acf(buffer);
          
          // Create points for the ACF plot with lag as x and ACF as y
          std::vector<rerun::Position2D> points;
          for (size_t lag = 0; lag < acf.size(); ++lag) {
            points.push_back({static_cast<float>(lag), static_cast<float>(acf[lag])});
          }
          
          // Log the points as a single series, using keypath as the identifier
          // _rec->log("acf_plot",
          //   rerun::Points2D(points)
          //     .with_colors({rerun::Color(0.0f, 0.0f, 1.0f)})  // blue color for the series
          //     .with_labels({keypath})  // use keypath as series name
          // );
          _rec->log("acf_plot/" + keypath, 
            rerun::BarChart::f64(acf));
        }
      }
    }
    
    return return_type::success;
  }

  void set_params(void const *params) override { 
    // Call the parent class method to set the common parameters 
    // (e.g. agent_id, etc.)
    Sink::set_params(params);

    // provide sensible defaults for the parameters
    _params["keypaths"] = json::array();  // empty array by default
    _params["acf_keypaths"] = json::array();  // empty array by default
    _params["acf_width"] = 100;  // default ACF width
    _params["time"] = "timecode";
    
    // then merge the defaults with the actually provided parameters
    _params.merge_patch(*(json *)params);

    // Load the keypaths configuration
    _keypaths.clear();
    if (_params.contains("keypaths") && _params["keypaths"].is_array()) {
      for (const auto& path : _params["keypaths"]) {
        if (path.is_string()) {
          _keypaths.push_back(path.get<std::string>());
        }
      }
    }

    // Load ACF configuration
    _acf_keypaths.clear();
    if (_params.contains("acf_keypaths") && _params["acf_keypaths"].is_array()) {
      for (const auto& path : _params["acf_keypaths"]) {
        if (path.is_string()) {
          _acf_keypaths.push_back(path.get<std::string>());
          // Initialize buffer for this keypath
          _signal_buffers[path.get<std::string>()];
        }
      }
    }

    // Update ACF width if specified
    if (_params.contains("acf_width") && _params["acf_width"].is_number()) {
      _acf_width = _params["acf_width"].get<size_t>();
      _window_size = _acf_width * 10;  // Maintain 10x buffer size
    }
  }

  // Implement this method if you want to provide additional information
  map<string, string> info() override { 
    // return a map of strings with additional information about the plugin
    // it is used to print the information about the plugin when it is loaded
    // by the agent
    
    return {
      {"ACF Width", std::to_string(_acf_width)},
      {"ACF Keypaths", _acf_keypaths.empty() ? "None" : json(_acf_keypaths).dump()},
      {"Keypaths", _keypaths.empty() ? "None" : json(_keypaths).dump()},
      {"Time column", _params["time"].empty() ? "timecode" : _params["time"].get<std::string>()}
    };
    
  };

};



/*
  ____  _             _             _      _                
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __ 
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |   
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|   
                |___/                                      
Enable the class as plugin 
*/
INSTALL_SINK_DRIVER(RerunnerPlugin, json)


/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/
int main(int argc, char const *argv[]) {
  RerunnerPlugin plugin;
  json input, params;
  
  // Set example values to params
  params["test"] = "value";

  // Set the parameters
  plugin.set_params(&params);

  // Process data
  plugin.load_data(input);

  return 0;
}
